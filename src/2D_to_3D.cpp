
#include "common.h"

using namespace std;


///Opening window Xposition
int windowPosX4=640;
///Opening window Yposition
int windowPosY4=480;
///Opening window Width
int windowWidth4= 50;
///Opening Window Height
int windowHeight4=50;
///Total number of points in front view
int number_of_points_front=0; 
///Total number of points in top0 view
int number_of_points_top=0;
///Total number of points in side view
int number_of_points_side=0;
///Total number of points in 3D object
int number_of_points1;
///Number of edges in top view
int tEdges;
///Number of edges in top view
int fEdges; 
///Number of edges in top view
int sEdges;

///Front View vertex Matrix : (index,x,y)
float Front[100][3];  
///Front View vertex Matrix : (index,x,z)
float Top[100][3];   
///Front View vertex Matrix : (index,z,y)
float Side[100][3]; 

///Edge Matrix between points in front view
int edges_front[4950][2]; 
///Edge Matrix between points in side  view
int edges_side[4950][2];
///Edge Matrix between points in top view
int edges_top[4950][2];
///Binary edge matrix for front view
int edges_bin_front[100][100];
///Binary edge matrix for side view
int edges_bin_side[100][100];
///Binary edge matrix for top view
int edges_bin_top[100][100];

///Final 3D coordinates 
float final_vertices1[100][3]; 
///Binary edge matrix for 3D object
int final_edges1[100][100]; 
///Whether the window is full screen or not
bool fullScreenMode = true; // Full-screen or windowed mode?
///Angle of rotation about X axis
float rotX=0;
///Angle of rotation about Y axis
float rotY=0;  // For rotation according to the user
///Points on each face generated
int points_on_face[30];
///Number of edges in that particular face generated
int edges_count=0;
///Variable to keep a track of which edges have been transversed already
int face_check[100][100];
///Epsilon to compare floating point numbers
float epsilon = 0.01f;
///Total number of faces generated by the program
int number_of_faces_improv=0;
///Contains number of eges_count for each face generated
int edges_count_matrix[500]; //Contains number of edge counts for each face
///Master matrix containing index of points on each face generated
int all_faces[500][30];//Total maximum number of faces possible = 500, each face has 30 points

bool is_Equal_Zero(float a){
	///Function which tells whether a floating number is within epsilon distance of 0 or not
	if (a>0){
		if(a<epsilon)
			return true;
		else
			return false;
	}
	else
		if(-1.0*a>epsilon)
			return false;
		else 
			return true;
}
 void drawtext2(const char* text,int length, int x,int y)
{
	///Function to include text in GL Window
   glMatrixMode(GL_PROJECTION);
   double *matrix = new double[16];
   glGetDoublev(GL_PROJECTION_MATRIX,matrix);
   glLoadIdentity();
   glOrtho(0,800,0,600  ,-5,5);
   glMatrixMode(GL_MODELVIEW);
   glLoadIdentity();
   glPushMatrix();
   glLoadIdentity();
   glRasterPos2i(x,y);
   for(int i=0;i<length;i++)
   {
      glutBitmapCharacter(GLUT_BITMAP_TIMES_ROMAN_24,(int)text[i]);
   }
   glPopMatrix();
   glMatrixMode(GL_PROJECTION);
   glLoadMatrixd(matrix);
   glMatrixMode(GL_MODELVIEW);
}
void face_detection(){
	///Function to generate face with help of edges found and points input
	float x1,x2,y1,y2,z1,z2,p,q,r,x,y,z,dot_product;
	int last_index, temp_index;
	int w=0,m=0,bro;
	for(int i=0; i<number_of_points1; i++){
		for(int j=0; j< number_of_points1; j++){
			edges_count=0;

			if(final_edges1[i][j]==1 && face_check[i][j]!=100){
			//There is and edge from i->j but not counted till now
				points_on_face[edges_count]=i;
				edges_count++;
				points_on_face[edges_count]=j;
            face_check[i][j]++;
				for(w=0; w<number_of_points1; w++){
					if(final_edges1[j][w]==1 && face_check[j][w]!=100 && w!=i){
						edges_count++;
						points_on_face[edges_count]=w;
                  face_check[j][w]++;
						break;
					}
				}
				//I have got two edges (three points)
				if(w < number_of_points1){
					x1=final_vertices1[i][0]-final_vertices1[j][0];
      			x2=final_vertices1[j][0]-final_vertices1[w][0];
      			y1=final_vertices1[i][1]-final_vertices1[j][1];
      			y2=final_vertices1[j][1]-final_vertices1[w][1];
      			z1=final_vertices1[i][2]-final_vertices1[j][2];
      			z2=final_vertices1[j][2]-final_vertices1[w][2];
      			p=y1*z2-y2*z1;
      			q=-1.0f*(x1*z2-x2*z1);
      			r=x1*y2-x2*y1;
      			//Normal to the plane formed by these two vectors
      			last_index = w;
               
               //cout << "Values are:";
               //cout << i << " " << j <<" "<< w << endl;
               m=0;   
               while((last_index != i) || m==number_of_points1){
                  //cout << last_index <<endl;
                  //cout << "Is it really Hurray?"<<endl;
      				temp_index = last_index;
                  //cout << edges_count<<endl;
      				for(m=0; m<number_of_points1; m++){
                     
      					if((final_edges1[temp_index][m]==1) && (face_check[temp_index][m]!=100) && (m!=points_on_face[edges_count-1])){
      						//checking for perpendicularity is remaining
                        //cout << m << " ";
      						x=final_vertices1[temp_index][0]-final_vertices1[m][0];
      						y=final_vertices1[temp_index][1]-final_vertices1[m][1];
      						z=final_vertices1[temp_index][2]-final_vertices1[m][2];
      						dot_product = p*x + q*y + r*z;
                        //cout << "Dot product at m= " << m << " is" << dot_product<< endl;
      						if(is_Equal_Zero(dot_product)){
      						//next edge has passed each criteria then add
      							edges_count++;
      							points_on_face[edges_count] = m;
                           face_check[temp_index][m]++;
      							last_index = m;
      							break;
      						}
      					}
      				}
                  //cout <<endl<< last_index<<endl;
      			}
               edges_count_matrix[number_of_faces_improv] = edges_count;
               for(int b=0; b<edges_count; b++){
                  all_faces[number_of_faces_improv][b] = points_on_face[b];
               }
               number_of_faces_improv++;
      		}
     			//Now draw that particular face
         }                
		}
	}
}

void draw_wireframe(){
	///draws the wire-frame of the 3D object
   glLineWidth(5.0f);
   glColor3f(0.7f, 0.7f, 0.7f);
   for(int i=0; i<number_of_points1; i++){
      for(int j=0; j<i; j++){
         if(final_edges1[i][j]==1){
            glBegin(GL_LINES);
               glVertex3f(final_vertices1[i][0], final_vertices1[i][1], final_vertices1[i][2]);
               glVertex3f(final_vertices1[j][0], final_vertices1[j][1], final_vertices1[j][2]);
            glEnd();
         }   
      }
   }
}
void draw4(){
   ///Draws the 3D object from vertex, edge matrix and face detection algorithm
   int temp,bro;
   glColor3f(0.0f, 0.0f, 0.0f);
   for(int i=0; i<number_of_faces_improv; i++){
      temp=edges_count_matrix[i];
      glBegin(GL_POLYGON);
      for(int j=0; j<temp; j++){
         bro=all_faces[i][j];
         glVertex3f(final_vertices1[bro][0], final_vertices1[bro][1], final_vertices1[bro][2]);
      }
      glEnd();
   }


   glLineWidth(5.0f);
   glColor3f(0.7f, 0.7f, 0.7f);
   for(int i=0; i<number_of_points1; i++){
      for(int j=0; j<i; j++){
         if(final_edges1[i][j]==1){
            glBegin(GL_LINES);
               glVertex3f(final_vertices1[i][0], final_vertices1[i][1], final_vertices1[i][2]);
               glVertex3f(final_vertices1[j][0], final_vertices1[j][1], final_vertices1[j][2]);
            glEnd();
         }   
      }
   }
}
void display4() {
/// Callback handler for window re-paint event 
   
      std::string text2;

   text2= "ROTATION:ARROW KEYS    EXIT:ESCAPE    MINIMIZE:F1   ZOOM:PGUP/PGDN";
   drawtext2(text2.data(),text2.size(),20,25);  
   glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT); 
   glMatrixMode(GL_MODELVIEW);     
      glLoadIdentity();  
            
      glPushMatrix();

      glTranslatef(3.0f, 2.0f, 0.0f);  
      glRotatef(rotX, 1.0f, 0.0f, 0.0f);  
      glRotatef(rotY, 0.0f, 1.0f, 0.0f);
      draw4();
      glPopMatrix();

      glTranslatef(-3.0f, -2.0f, 0.0f);
      glRotatef(rotX, 1.0f, 0.0f, 0.0f);  
      glRotatef(rotY, 0.0f, 1.0f, 0.0f);
      draw_wireframe();
      glutSwapBuffers(); 
}
 

void specialKeys4(int key, int x, int y) {
	///Rotation of object via arrow keys, toggle between full screen mode and window mode as well as zoom in/zoom out the object
   switch (key) {
      case GLUT_KEY_F1:    
         fullScreenMode = !fullScreenMode;         
         if (fullScreenMode) {                    
            windowPosX4   = glutGet(GLUT_WINDOW_X); 
            windowPosY4   = glutGet(GLUT_WINDOW_Y);
            windowWidth4  = glutGet(GLUT_WINDOW_WIDTH);
            windowHeight4 = glutGet(GLUT_WINDOW_HEIGHT);
            glutFullScreen();                      
         } else {                                         
            glutReshapeWindow(windowWidth4, windowHeight4); 
            glutPositionWindow(windowPosX4, windowPosX4);   
         }
      break;
      
      case GLUT_KEY_UP:
         rotX -= 5.0;
      break;
      case GLUT_KEY_DOWN:
         rotX += 5.0;
      break;     
      case GLUT_KEY_LEFT:
         rotY -= 5.0;
      break;      
      case GLUT_KEY_RIGHT:
         rotY += 5.0;
      break;
      case GLUT_KEY_PAGE_UP: 
         for(int i=0; i<number_of_points1; i++){
            final_vertices1[i][0] *= 1.05f;
            final_vertices1[i][1] *= 1.05f;
            final_vertices1[i][2] *= 1.05f;
         }
      break;      
      case GLUT_KEY_PAGE_DOWN: 
         for(int i=0; i<number_of_points1; i++){
            final_vertices1[i][0] *= 0.95f;
            final_vertices1[i][1] *= 0.95f;
            final_vertices1[i][2] *= 0.95f;
         }
      break;
   }   
}

void edge_transformations1(){  
   ///To get binary edge matrix for each view
   for(int i=0; i<number_of_points1; i++)
      for(int j=0; j<number_of_points1; j++)
         edges_bin_front[i][j] = 0;

   for(int i=0; i<number_of_points1; i++)
      edges_bin_front[i][i] =1;
   for(int i=0; i<fEdges; i++){
      edges_bin_front[edges_front[i][0]][edges_front[i][1]]=1;
      edges_bin_front[edges_front[i][1]][edges_front[i][0]]=1;
   }

   for(int i=0; i<number_of_points1; i++)
      for(int j=0; j<number_of_points1; j++)
         edges_bin_top[i][j] = 0;

   for(int i=0; i<number_of_points1; i++)
      edges_bin_top[i][i] =1;
   for(int i=0; i<tEdges; i++){
      edges_bin_top[edges_top[i][0]][edges_top[i][1]]=1;
      edges_bin_top[edges_top[i][1]][edges_top[i][0]]=1;
   }

   for(int i=0; i<number_of_points1; i++)
      for(int j=0; j<number_of_points1; j++)
         edges_bin_side[i][j] = 0;

   for(int i=0; i<number_of_points1; i++)
      edges_bin_side[i][i] =1;
   for(int i=0; i<sEdges; i++){
      edges_bin_side[edges_side[i][0]][edges_side[i][1]]=1;
      edges_bin_side[edges_side[i][1]][edges_side[i][0]]=1;
   }
}


void get_coordinates1(){
	///Get 3D coordinate matrix from 2D coordinate matrices
   int index;
   for(int i=0; i<number_of_points1; i++){
      //Front se x aur y milenge put at place
      index = (int)Front[i][0];

      final_vertices1[index][0] = Front[i][1];  //All x coordinates are set
      final_vertices1[index][1] = Front[i][2];  //All y coordinates are set
   }
   for(int i=0; i<number_of_points1; i++){
      index = (int)Top[i][0];
      final_vertices1[index][2] = Top[i][2];  //All z coordinates are also set
   }
   /*
   for(int i=0; i<number_of_points1; i++){
      cout << final_vertices1[i][0] <<" " << final_vertices1[i][1] << " " << final_vertices1[i][2] << " " << endl;
   }
   */
}


void get_edge_matrix(){
	///To get 3D edge matrix(binary) from 2D edge matrices(binary) 
   for(int i=0; i<number_of_points1; i++){
      for(int j=0; j<number_of_points1; j++)
         if((edges_bin_top[i][j]==1) && (edges_bin_side[i][j]==1) && (edges_bin_front[i][j]==1))
            final_edges1[i][j] = 1;
         else
            final_edges1[i][j]=0;
   }
}

/* Main function: GLUT runs as a console application starting at main() */
void call_2D_t0_3D(int argc, char** argv) {
	///Acts like main function (Calling GLUT and self-made fnctions)
   ifstream infile;

   infile.open(argv[1]);
   infile >> number_of_points_front;
   number_of_points1 = number_of_points_front;
   /*Front view*/
   //Verices
   //cout << "Enter Front Face vertices";
   for(int i=0; i<number_of_points1; i++){
      infile >> Front[i][0] >> Front[i][1] >> Front[i][2];  //(index,x,y)
   }
   //Edges (defined through index)
   //cout << "Enter front face edge pairs";
   infile >> fEdges; //Number of neighbours in top view
   for(int i=0; i<fEdges; i++){
      infile >> edges_front[i][0] >> edges_front[i][1]; //Put the indices of the vertices that are neighbours
   }
   infile.close();

   infile.open(argv[2]);
   infile >> number_of_points_top;
   /*Top view*/
   //Verices
   //cout << "Enter Top Face vertices";
   for(int i=0; i<number_of_points1; i++){
      infile >> Top[i][0] >> Top[i][1] >> Top[i][2];  //(index,x,z)
   }
   //Edges (defined through index)
   //cout << "Enter Top face edge pairs";
   infile >> tEdges; //Number of neighbours in top view
   for(int i=0; i<tEdges; i++){
      infile >> edges_top[i][0] >> edges_top[i][1]; //Put the indices of the vertices that are neighbours
   }
   infile.close();

   infile.open(argv[3]);
   infile >> number_of_points_side;
   /*Side view*/
   //Verices
   //cout << "Enter Side face vertices";
   for(int i=0; i<number_of_points1; i++){
      infile >> Side[i][0] >> Side[i][1] >> Side[i][2];  //(index,z,y)
   }
   //Edges (defined through index)
   //cout << "Enter Side face edge pairs";
   infile >> sEdges; //Number of neighbours in top view
   for(int i=0; i<sEdges; i++){
      infile >> edges_side[i][0] >> edges_side[i][1]; //Put the indices of the vertices that are neighbours
   }
   infile.close();

   for(int i=0; i<number_of_points1; i++){
       for(int j=0; j<number_of_points1; j++){
           if(i==j)
           	face_check[i][j]=1;
           else
           	face_check[i][j]=0;
       }
   }
   /*Self-made functions*/
   get_coordinates1();  //Converts the 2D coordinates to 3D coordinates
   edge_transformations1();  //Get three n*n matrices of edges
   get_edge_matrix();  //Get the final edge matrix
   char title[] = "2D to 3D";
   face_detection();

   /*GLUT Functions*/
   glutInit(&argc, argv);            // Initialize GLUT
   glutInitDisplayMode(GLUT_DOUBLE); // Enable double buffered mode
   glutInitWindowSize(windowWidth4, windowHeight4);  // Initial window width and height
   glutInitWindowPosition(windowPosX4, windowPosY4); // Initial window top-left corner (x, y)
   glutCreateWindow(title);          // Create window with the given title
   glutDisplayFunc(display4);       // Register callback handler for window re-paint event
   glutReshapeFunc(reshape);       // Register callback handler for window re-size event
   glutKeyboardFunc(keyboard);   // Register callback handler for special-key event
   glutSpecialFunc(specialKeys4); // Register callback handler for special-key event
   glutFullScreen();             // Put into full screen
   initGL();                       // Our own OpenGL initialization
   glutTimerFunc(0, timer, 0);     // First timer call immediately [NEW]glutSetOption(GLUT_ACTION_ON_WINDOW_CLOSE, GLUT_ACTION_GLUTMAINLOOP_RETURNS);
   glutSetOption(GLUT_ACTION_ON_WINDOW_CLOSE, GLUT_ACTION_GLUTMAINLOOP_RETURNS);
   glutMainLoop();                 // Enter the infinite event-processing loop
   return ;
}
